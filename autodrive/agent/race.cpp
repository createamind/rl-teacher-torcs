// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `race.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <race.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Race::DriveInfo> iceC_Race_DriveInfo_init("::Race::DriveInfo");

const ::IceInternal::DefaultValueFactoryInit<::Race::Image> iceC_Race_Image_init("::Race::Image");

const ::IceInternal::DefaultValueFactoryInit<::Race::Status> iceC_Race_Status_init("::Race::Status");

const ::IceInternal::DefaultValueFactoryInit<::Race::BotInitParam> iceC_Race_BotInitParam_init("::Race::BotInitParam");

const ::IceInternal::DefaultValueFactoryInit<::Race::BotRaceInitParam> iceC_Race_BotRaceInitParam_init("::Race::BotRaceInitParam");

const ::IceInternal::DefaultValueFactoryInit<::Race::BotInfo> iceC_Race_BotInfo_init("::Race::BotInfo");

const ::IceInternal::DefaultValueFactoryInit<::Race::EventParams> iceC_Race_EventParams_init("::Race::EventParams");

const ::IceInternal::DefaultValueFactoryInit<::Race::StepParam> iceC_Race_StepParam_init("::Race::StepParam");

const ::IceInternal::DefaultValueFactoryInit<::Race::ResetParam> iceC_Race_ResetParam_init("::Race::ResetParam");

const ::IceInternal::DefaultValueFactoryInit<::Race::StepResult> iceC_Race_StepResult_init("::Race::StepResult");

const ::IceInternal::DefaultValueFactoryInit<::Race::ServerInitParam> iceC_Race_ServerInitParam_init("::Race::ServerInitParam");

const ::std::string iceC_Race_Pool_ids[2] =
{
    "::Ice::Object",
    "::Race::Pool"
};
const ::std::string iceC_Race_Pool_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "onEvent",
    "predict"
};
const ::std::string iceC_Race_Pool_onEvent_name = "onEvent";
const ::std::string iceC_Race_Pool_predict_name = "predict";

const ::std::string iceC_Race_Server_ids[2] =
{
    "::Ice::Object",
    "::Race::Server"
};
const ::std::string iceC_Race_Server_ops[] =
{
    "getBots",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "init",
    "reset",
    "shutdown",
    "step"
};
const ::std::string iceC_Race_Server_init_name = "init";
const ::std::string iceC_Race_Server_getBots_name = "getBots";
const ::std::string iceC_Race_Server_step_name = "step";
const ::std::string iceC_Race_Server_reset_name = "reset";
const ::std::string iceC_Race_Server_shutdown_name = "shutdown";

}

bool
Race::Pool::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_Pool_ids, iceC_Race_Pool_ids + 2, s);
}

::std::vector<::std::string>
Race::Pool::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Race_Pool_ids[0], &iceC_Race_Pool_ids[2]);
}

::std::string
Race::Pool::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::Pool::ice_staticId()
{
    static const ::std::string typeId = "::Race::Pool";
    return typeId;
}

bool
Race::Pool::_iceD_onEvent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_evt;
    ::std::shared_ptr<::Race::EventParams> iceP_param;
    istr->readAll(iceP_evt, iceP_param);
    istr->readPendingValues();
    inS.endReadParams();
    this->onEvent(::std::move(iceP_evt), ::std::move(iceP_param), current);
    inS.writeEmptyParams();
    return true;
}

bool
Race::Pool::_iceD_predict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Race::StatusList iceP_status;
    istr->readAll(iceP_status);
    istr->readPendingValues();
    inS.endReadParams();
    ::Race::DriveInfoList ret = this->predict(::std::move(iceP_status), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
Race::Pool::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Race_Pool_ops, iceC_Race_Pool_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Race_Pool_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_onEvent(in, current);
        }
        case 5:
        {
            return _iceD_predict(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}

bool
Race::Server::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_Server_ids, iceC_Race_Server_ids + 2, s);
}

::std::vector<::std::string>
Race::Server::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Race_Server_ids[0], &iceC_Race_Server_ids[2]);
}

::std::string
Race::Server::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::Server::ice_staticId()
{
    static const ::std::string typeId = "::Race::Server";
    return typeId;
}

bool
Race::Server::_iceD_init(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Identity iceP_ident;
    ::std::shared_ptr<::Race::ServerInitParam> iceP_param;
    istr->readAll(iceP_ident, iceP_param);
    istr->readPendingValues();
    inS.endReadParams();
    this->init(::std::move(iceP_ident), ::std::move(iceP_param), current);
    inS.writeEmptyParams();
    return true;
}

bool
Race::Server::_iceD_getBots(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::Race::BotInfoList ret = this->getBots(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
Race::Server::_iceD_step(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::Race::StepParam> iceP_param;
    istr->readAll(iceP_param);
    istr->readPendingValues();
    inS.endReadParams();
    ::std::shared_ptr<::Race::StepResult> ret = this->step(::std::move(iceP_param), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
Race::Server::_iceD_reset(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::Race::ResetParam> iceP_param;
    istr->readAll(iceP_param);
    istr->readPendingValues();
    inS.endReadParams();
    ::std::shared_ptr<::Race::StepResult> ret = this->reset(::std::move(iceP_param), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
Race::Server::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}

bool
Race::Server::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Race_Server_ops, iceC_Race_Server_ops + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Race_Server_ops)
    {
        case 0:
        {
            return _iceD_getBots(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_init(in, current);
        }
        case 6:
        {
            return _iceD_reset(in, current);
        }
        case 7:
        {
            return _iceD_shutdown(in, current);
        }
        case 8:
        {
            return _iceD_step(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}

Race::DriveInfo::~DriveInfo()
{
}

const ::std::string&
Race::DriveInfo::ice_staticId()
{
    static const ::std::string typeId = "::Race::DriveInfo";
    return typeId;
}

Race::Image::~Image()
{
}

const ::std::string&
Race::Image::ice_staticId()
{
    static const ::std::string typeId = "::Race::Image";
    return typeId;
}

Race::Status::~Status()
{
}

const ::std::string&
Race::Status::ice_staticId()
{
    static const ::std::string typeId = "::Race::Status";
    return typeId;
}

Race::BotInitParam::~BotInitParam()
{
}

const ::std::string&
Race::BotInitParam::ice_staticId()
{
    static const ::std::string typeId = "::Race::BotInitParam";
    return typeId;
}

Race::BotRaceInitParam::~BotRaceInitParam()
{
}

const ::std::string&
Race::BotRaceInitParam::ice_staticId()
{
    static const ::std::string typeId = "::Race::BotRaceInitParam";
    return typeId;
}

Race::BotInfo::~BotInfo()
{
}

const ::std::string&
Race::BotInfo::ice_staticId()
{
    static const ::std::string typeId = "::Race::BotInfo";
    return typeId;
}

Race::EventParams::~EventParams()
{
}

const ::std::string&
Race::EventParams::ice_staticId()
{
    static const ::std::string typeId = "::Race::EventParams";
    return typeId;
}

Race::StepParam::~StepParam()
{
}

const ::std::string&
Race::StepParam::ice_staticId()
{
    static const ::std::string typeId = "::Race::StepParam";
    return typeId;
}

Race::ResetParam::~ResetParam()
{
}

const ::std::string&
Race::ResetParam::ice_staticId()
{
    static const ::std::string typeId = "::Race::ResetParam";
    return typeId;
}

Race::StepResult::~StepResult()
{
}

const ::std::string&
Race::StepResult::ice_staticId()
{
    static const ::std::string typeId = "::Race::StepResult";
    return typeId;
}

Race::ServerInitParam::~ServerInitParam()
{
}

const ::std::string&
Race::ServerInitParam::ice_staticId()
{
    static const ::std::string typeId = "::Race::ServerInitParam";
    return typeId;
}

void
Race::PoolPrx::_iceI_onEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_evt, const ::std::shared_ptr<::Race::EventParams>& iceP_param, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Race_Pool_onEvent_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_evt, iceP_param);
            ostr->writePendingValues();
        },
        nullptr);
}

void
Race::PoolPrx::_iceI_predict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Race::DriveInfoList>>& outAsync, const ::Race::StatusList& iceP_status, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Race_Pool_predict_name);
    outAsync->invoke(iceC_Race_Pool_predict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_status);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::Race::DriveInfoList ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::std::shared_ptr<::Ice::ObjectPrx>
Race::PoolPrx::_newInstance() const
{
    return ::IceInternal::createProxy<PoolPrx>();
}

const ::std::string&
Race::PoolPrx::ice_staticId()
{
    return Race::Pool::ice_staticId();
}

void
Race::ServerPrx::_iceI_init(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Identity& iceP_ident, const ::std::shared_ptr<::Race::ServerInitParam>& iceP_param, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Race_Server_init_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_ident, iceP_param);
            ostr->writePendingValues();
        },
        nullptr);
}

void
Race::ServerPrx::_iceI_getBots(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Race::BotInfoList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Race_Server_getBots_name);
    outAsync->invoke(iceC_Race_Server_getBots_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::Race::BotInfoList ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Race::ServerPrx::_iceI_step(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Race::StepResult>>>& outAsync, const ::std::shared_ptr<::Race::StepParam>& iceP_param, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Race_Server_step_name);
    outAsync->invoke(iceC_Race_Server_step_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_param);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::Race::StepResult> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Race::ServerPrx::_iceI_reset(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Race::StepResult>>>& outAsync, const ::std::shared_ptr<::Race::ResetParam>& iceP_param, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Race_Server_reset_name);
    outAsync->invoke(iceC_Race_Server_reset_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_param);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::Race::StepResult> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Race::ServerPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Race_Server_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::std::shared_ptr<::Ice::ObjectPrx>
Race::ServerPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ServerPrx>();
}

const ::std::string&
Race::ServerPrx::ice_staticId()
{
    return Race::Server::ice_staticId();
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Race_Pool_onEvent_name = "onEvent";

const ::std::string iceC_Race_Pool_predict_name = "predict";

const ::std::string iceC_Race_Server_init_name = "init";

const ::std::string iceC_Race_Server_getBots_name = "getBots";

const ::std::string iceC_Race_Server_step_name = "step";

const ::std::string iceC_Race_Server_reset_name = "reset";

const ::std::string iceC_Race_Server_shutdown_name = "shutdown";

}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::DriveInfo* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::DriveInfo>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::DriveInfo;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::DriveInfo::_newInstance() const
{
    return new DriveInfo;
}

const ::std::string&
IceProxy::Race::DriveInfo::ice_staticId()
{
    return ::Race::DriveInfo::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::Image* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::Image>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::Image;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::Image::_newInstance() const
{
    return new Image;
}

const ::std::string&
IceProxy::Race::Image::ice_staticId()
{
    return ::Race::Image::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::Status* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::Status>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::Status;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::Status::_newInstance() const
{
    return new Status;
}

const ::std::string&
IceProxy::Race::Status::ice_staticId()
{
    return ::Race::Status::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::BotInitParam* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::BotInitParam>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::BotInitParam;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::BotInitParam::_newInstance() const
{
    return new BotInitParam;
}

const ::std::string&
IceProxy::Race::BotInitParam::ice_staticId()
{
    return ::Race::BotInitParam::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::BotRaceInitParam* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::BotRaceInitParam>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::BotRaceInitParam;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::BotRaceInitParam::_newInstance() const
{
    return new BotRaceInitParam;
}

const ::std::string&
IceProxy::Race::BotRaceInitParam::ice_staticId()
{
    return ::Race::BotRaceInitParam::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::BotInfo* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::BotInfo>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::BotInfo;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::BotInfo::_newInstance() const
{
    return new BotInfo;
}

const ::std::string&
IceProxy::Race::BotInfo::ice_staticId()
{
    return ::Race::BotInfo::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::EventParams* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::EventParams>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::EventParams;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::EventParams::_newInstance() const
{
    return new EventParams;
}

const ::std::string&
IceProxy::Race::EventParams::ice_staticId()
{
    return ::Race::EventParams::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::StepParam* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::StepParam>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::StepParam;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::StepParam::_newInstance() const
{
    return new StepParam;
}

const ::std::string&
IceProxy::Race::StepParam::ice_staticId()
{
    return ::Race::StepParam::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::ResetParam* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::ResetParam>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::ResetParam;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::ResetParam::_newInstance() const
{
    return new ResetParam;
}

const ::std::string&
IceProxy::Race::ResetParam::ice_staticId()
{
    return ::Race::ResetParam::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::StepResult* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::StepResult>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::StepResult;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::StepResult::_newInstance() const
{
    return new StepResult;
}

const ::std::string&
IceProxy::Race::StepResult::ice_staticId()
{
    return ::Race::StepResult::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::ServerInitParam* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::ServerInitParam>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::ServerInitParam;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::Race::ServerInitParam::_newInstance() const
{
    return new ServerInitParam;
}

const ::std::string&
IceProxy::Race::ServerInitParam::ice_staticId()
{
    return ::Race::ServerInitParam::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::Pool* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::Pool>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::Pool;
        v->_copyFrom(proxy);
    }
}

::Ice::AsyncResultPtr
IceProxy::Race::Pool::_iceI_begin_onEvent(const ::std::string& iceP_evt, const ::Race::EventParamsPtr& iceP_param, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Race_Pool_onEvent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Race_Pool_onEvent_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_evt);
        ostr->write(iceP_param);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Race_Pool_onEvent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Race::Pool::end_onEvent(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Race_Pool_onEvent_name);
}

::Ice::AsyncResultPtr
IceProxy::Race::Pool::_iceI_begin_predict(const ::Race::StatusList& iceP_status, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Race_Pool_predict_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Race_Pool_predict_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Race_Pool_predict_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_status);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Race_Pool_predict_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Race::DriveInfoList
IceProxy::Race::Pool::end_predict(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Race_Pool_predict_name);
    ::Race::DriveInfoList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::IceProxy::Ice::Object*
IceProxy::Race::Pool::_newInstance() const
{
    return new Pool;
}

const ::std::string&
IceProxy::Race::Pool::ice_staticId()
{
    return ::Race::Pool::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::Race::upCast(::IceProxy::Race::Server* p) { return p; }

void
::IceProxy::Race::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::Race::Server>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Race::Server;
        v->_copyFrom(proxy);
    }
}

::Ice::AsyncResultPtr
IceProxy::Race::Server::_iceI_begin_init(const ::Ice::Identity& iceP_ident, const ::Race::ServerInitParamPtr& iceP_param, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Race_Server_init_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Race_Server_init_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_ident);
        ostr->write(iceP_param);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Race_Server_init_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Race::Server::end_init(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Race_Server_init_name);
}

::Ice::AsyncResultPtr
IceProxy::Race::Server::_iceI_begin_getBots(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Race_Server_getBots_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Race_Server_getBots_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Race_Server_getBots_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Race_Server_getBots_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Race::BotInfoList
IceProxy::Race::Server::end_getBots(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Race_Server_getBots_name);
    ::Race::BotInfoList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Race::Server::_iceI_begin_step(const ::Race::StepParamPtr& iceP_param, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Race_Server_step_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Race_Server_step_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Race_Server_step_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_param);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Race_Server_step_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Race::StepResultPtr
IceProxy::Race::Server::end_step(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Race_Server_step_name);
    ::Race::StepResultPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Race::Server::_iceI_begin_reset(const ::Race::ResetParamPtr& iceP_param, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Race_Server_reset_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Race_Server_reset_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Race_Server_reset_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_param);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Race_Server_reset_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Race::StepResultPtr
IceProxy::Race::Server::end_reset(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Race_Server_reset_name);
    ::Race::StepResultPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Race::Server::_iceI_begin_shutdown(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Race_Server_shutdown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Race_Server_shutdown_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Race_Server_shutdown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Race::Server::end_shutdown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Race_Server_shutdown_name);
}

::IceProxy::Ice::Object*
IceProxy::Race::Server::_newInstance() const
{
    return new Server;
}

const ::std::string&
IceProxy::Race::Server::ice_staticId()
{
    return ::Race::Server::ice_staticId();
}

Race::DriveInfo::~DriveInfo()
{
}

::Ice::Object* Race::upCast(::Race::DriveInfo* p) { return p; }

::Ice::ObjectPtr
Race::DriveInfo::ice_clone() const
{
    ::Ice::Object* p = new DriveInfo(*this);
    return p;
}

namespace
{
const ::std::string iceC_Race_DriveInfo_ids[2] =
{
    "::Ice::Object",
    "::Race::DriveInfo"
};

}

bool
Race::DriveInfo::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_DriveInfo_ids, iceC_Race_DriveInfo_ids + 2, s);
}

::std::vector< ::std::string>
Race::DriveInfo::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_DriveInfo_ids[0], &iceC_Race_DriveInfo_ids[2]);
}

const ::std::string&
Race::DriveInfo::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::DriveInfo::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::DriveInfo";
    return typeId;
#else
    return iceC_Race_DriveInfo_ids[1];
#endif
}

void
Race::DriveInfo::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::DriveInfo, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::DriveInfo::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::DriveInfo, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::DriveInfo> iceC_Race_DriveInfo_init("::Race::DriveInfo");
}

::Ice::ValueFactoryPtr
Race::DriveInfo::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::DriveInfo::ice_staticId());
}

void
Race::_icePatchObjectPtr(DriveInfoPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::DriveInfoPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::DriveInfo::ice_staticId(), v);
    }
}

Race::Image::~Image()
{
}

::Ice::Object* Race::upCast(::Race::Image* p) { return p; }

::Ice::ObjectPtr
Race::Image::ice_clone() const
{
    ::Ice::Object* p = new Image(*this);
    return p;
}

namespace
{
const ::std::string iceC_Race_Image_ids[2] =
{
    "::Ice::Object",
    "::Race::Image"
};

}

bool
Race::Image::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_Image_ids, iceC_Race_Image_ids + 2, s);
}

::std::vector< ::std::string>
Race::Image::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_Image_ids[0], &iceC_Race_Image_ids[2]);
}

const ::std::string&
Race::Image::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::Image::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::Image";
    return typeId;
#else
    return iceC_Race_Image_ids[1];
#endif
}

void
Race::Image::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::Image, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::Image::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::Image, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::Image> iceC_Race_Image_init("::Race::Image");
}

::Ice::ValueFactoryPtr
Race::Image::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::Image::ice_staticId());
}

void
Race::_icePatchObjectPtr(ImagePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::ImagePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::Image::ice_staticId(), v);
    }
}

Race::Status::~Status()
{
}

::Ice::Object* Race::upCast(::Race::Status* p) { return p; }


#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Race::Status::ice_clone() const
{
    ::Ice::Object* p = new Status(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Race_Status_ids[2] =
{
    "::Ice::Object",
    "::Race::Status"
};

}

bool
Race::Status::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_Status_ids, iceC_Race_Status_ids + 2, s);
}

::std::vector< ::std::string>
Race::Status::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_Status_ids[0], &iceC_Race_Status_ids[2]);
}

const ::std::string&
Race::Status::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::Status::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::Status";
    return typeId;
#else
    return iceC_Race_Status_ids[1];
#endif
}

void
Race::Status::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(driveInfo)
    {
        if((::Race::upCast(driveInfo.get())->_iceGcVisit(v_)))
        {
            driveInfo = 0;
        }
    }
    if(image)
    {
        if((::Race::upCast(image.get())->_iceGcVisit(v_)))
        {
            image = 0;
        }
    }
}

void
Race::Status::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::Status, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::Status::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::Status, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::Status> iceC_Race_Status_init("::Race::Status");
}

::Ice::ValueFactoryPtr
Race::Status::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::Status::ice_staticId());
}

void
Race::_icePatchObjectPtr(StatusPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::StatusPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::Status::ice_staticId(), v);
    }
}

Race::BotInitParam::~BotInitParam()
{
}

::Ice::Object* Race::upCast(::Race::BotInitParam* p) { return p; }

::Ice::ObjectPtr
Race::BotInitParam::ice_clone() const
{
    ::Ice::Object* p = new BotInitParam(*this);
    return p;
}

namespace
{
const ::std::string iceC_Race_BotInitParam_ids[2] =
{
    "::Ice::Object",
    "::Race::BotInitParam"
};

}

bool
Race::BotInitParam::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_BotInitParam_ids, iceC_Race_BotInitParam_ids + 2, s);
}

::std::vector< ::std::string>
Race::BotInitParam::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_BotInitParam_ids[0], &iceC_Race_BotInitParam_ids[2]);
}

const ::std::string&
Race::BotInitParam::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::BotInitParam::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::BotInitParam";
    return typeId;
#else
    return iceC_Race_BotInitParam_ids[1];
#endif
}

void
Race::BotInitParam::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::BotInitParam, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::BotInitParam::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::BotInitParam, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::BotInitParam> iceC_Race_BotInitParam_init("::Race::BotInitParam");
}

::Ice::ValueFactoryPtr
Race::BotInitParam::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::BotInitParam::ice_staticId());
}

void
Race::_icePatchObjectPtr(BotInitParamPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::BotInitParamPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::BotInitParam::ice_staticId(), v);
    }
}

Race::BotRaceInitParam::~BotRaceInitParam()
{
}

::Ice::Object* Race::upCast(::Race::BotRaceInitParam* p) { return p; }

::Ice::ObjectPtr
Race::BotRaceInitParam::ice_clone() const
{
    ::Ice::Object* p = new BotRaceInitParam(*this);
    return p;
}

namespace
{
const ::std::string iceC_Race_BotRaceInitParam_ids[2] =
{
    "::Ice::Object",
    "::Race::BotRaceInitParam"
};

}

bool
Race::BotRaceInitParam::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_BotRaceInitParam_ids, iceC_Race_BotRaceInitParam_ids + 2, s);
}

::std::vector< ::std::string>
Race::BotRaceInitParam::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_BotRaceInitParam_ids[0], &iceC_Race_BotRaceInitParam_ids[2]);
}

const ::std::string&
Race::BotRaceInitParam::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::BotRaceInitParam::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::BotRaceInitParam";
    return typeId;
#else
    return iceC_Race_BotRaceInitParam_ids[1];
#endif
}

void
Race::BotRaceInitParam::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::BotRaceInitParam, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::BotRaceInitParam::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::BotRaceInitParam, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::BotRaceInitParam> iceC_Race_BotRaceInitParam_init("::Race::BotRaceInitParam");
}

::Ice::ValueFactoryPtr
Race::BotRaceInitParam::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::BotRaceInitParam::ice_staticId());
}

void
Race::_icePatchObjectPtr(BotRaceInitParamPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::BotRaceInitParamPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::BotRaceInitParam::ice_staticId(), v);
    }
}

Race::BotInfo::~BotInfo()
{
}

::Ice::Object* Race::upCast(::Race::BotInfo* p) { return p; }

::Ice::ObjectPtr
Race::BotInfo::ice_clone() const
{
    ::Ice::Object* p = new BotInfo(*this);
    return p;
}

namespace
{
const ::std::string iceC_Race_BotInfo_ids[2] =
{
    "::Ice::Object",
    "::Race::BotInfo"
};

}

bool
Race::BotInfo::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_BotInfo_ids, iceC_Race_BotInfo_ids + 2, s);
}

::std::vector< ::std::string>
Race::BotInfo::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_BotInfo_ids[0], &iceC_Race_BotInfo_ids[2]);
}

const ::std::string&
Race::BotInfo::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::BotInfo::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::BotInfo";
    return typeId;
#else
    return iceC_Race_BotInfo_ids[1];
#endif
}

void
Race::BotInfo::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::BotInfo, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::BotInfo::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::BotInfo, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::BotInfo> iceC_Race_BotInfo_init("::Race::BotInfo");
}

::Ice::ValueFactoryPtr
Race::BotInfo::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::BotInfo::ice_staticId());
}

void
Race::_icePatchObjectPtr(BotInfoPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::BotInfoPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::BotInfo::ice_staticId(), v);
    }
}

Race::EventParams::~EventParams()
{
}

::Ice::Object* Race::upCast(::Race::EventParams* p) { return p; }

::Ice::ObjectPtr
Race::EventParams::ice_clone() const
{
    ::Ice::Object* p = new EventParams(*this);
    return p;
}

namespace
{
const ::std::string iceC_Race_EventParams_ids[2] =
{
    "::Ice::Object",
    "::Race::EventParams"
};

}

bool
Race::EventParams::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_EventParams_ids, iceC_Race_EventParams_ids + 2, s);
}

::std::vector< ::std::string>
Race::EventParams::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_EventParams_ids[0], &iceC_Race_EventParams_ids[2]);
}

const ::std::string&
Race::EventParams::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::EventParams::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::EventParams";
    return typeId;
#else
    return iceC_Race_EventParams_ids[1];
#endif
}

void
Race::EventParams::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::EventParams, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::EventParams::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::EventParams, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::EventParams> iceC_Race_EventParams_init("::Race::EventParams");
}

::Ice::ValueFactoryPtr
Race::EventParams::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::EventParams::ice_staticId());
}

void
Race::_icePatchObjectPtr(EventParamsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::EventParamsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::EventParams::ice_staticId(), v);
    }
}

Race::StepParam::~StepParam()
{
}

::Ice::Object* Race::upCast(::Race::StepParam* p) { return p; }


#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Race::StepParam::ice_clone() const
{
    ::Ice::Object* p = new StepParam(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Race_StepParam_ids[2] =
{
    "::Ice::Object",
    "::Race::StepParam"
};

}

bool
Race::StepParam::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_StepParam_ids, iceC_Race_StepParam_ids + 2, s);
}

::std::vector< ::std::string>
Race::StepParam::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_StepParam_ids[0], &iceC_Race_StepParam_ids[2]);
}

const ::std::string&
Race::StepParam::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::StepParam::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::StepParam";
    return typeId;
#else
    return iceC_Race_StepParam_ids[1];
#endif
}

void
Race::StepParam::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::Race::DriveInfoList::iterator _i0 = driveInfos.begin(); _i0 != driveInfos.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::Race::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
Race::StepParam::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::StepParam, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::StepParam::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::StepParam, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::StepParam> iceC_Race_StepParam_init("::Race::StepParam");
}

::Ice::ValueFactoryPtr
Race::StepParam::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::StepParam::ice_staticId());
}

void
Race::_icePatchObjectPtr(StepParamPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::StepParamPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::StepParam::ice_staticId(), v);
    }
}

Race::ResetParam::~ResetParam()
{
}

::Ice::Object* Race::upCast(::Race::ResetParam* p) { return p; }


#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Race::ResetParam::ice_clone() const
{
    ::Ice::Object* p = new ResetParam(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Race_ResetParam_ids[2] =
{
    "::Ice::Object",
    "::Race::ResetParam"
};

}

bool
Race::ResetParam::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_ResetParam_ids, iceC_Race_ResetParam_ids + 2, s);
}

::std::vector< ::std::string>
Race::ResetParam::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_ResetParam_ids[0], &iceC_Race_ResetParam_ids[2]);
}

const ::std::string&
Race::ResetParam::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::ResetParam::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::ResetParam";
    return typeId;
#else
    return iceC_Race_ResetParam_ids[1];
#endif
}

void
Race::ResetParam::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::Race::BotRaceInitParamList::iterator _i0 = raceInit.begin(); _i0 != raceInit.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::Race::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
Race::ResetParam::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::ResetParam, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::ResetParam::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::ResetParam, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::ResetParam> iceC_Race_ResetParam_init("::Race::ResetParam");
}

::Ice::ValueFactoryPtr
Race::ResetParam::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::ResetParam::ice_staticId());
}

void
Race::_icePatchObjectPtr(ResetParamPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::ResetParamPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::ResetParam::ice_staticId(), v);
    }
}

Race::StepResult::~StepResult()
{
}

::Ice::Object* Race::upCast(::Race::StepResult* p) { return p; }


#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Race::StepResult::ice_clone() const
{
    ::Ice::Object* p = new StepResult(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Race_StepResult_ids[2] =
{
    "::Ice::Object",
    "::Race::StepResult"
};

}

bool
Race::StepResult::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_StepResult_ids, iceC_Race_StepResult_ids + 2, s);
}

::std::vector< ::std::string>
Race::StepResult::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_StepResult_ids[0], &iceC_Race_StepResult_ids[2]);
}

const ::std::string&
Race::StepResult::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::StepResult::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::StepResult";
    return typeId;
#else
    return iceC_Race_StepResult_ids[1];
#endif
}

void
Race::StepResult::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::Race::StatusList::iterator _i0 = statusList.begin(); _i0 != statusList.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::Race::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
Race::StepResult::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::StepResult, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::StepResult::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::StepResult, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::StepResult> iceC_Race_StepResult_init("::Race::StepResult");
}

::Ice::ValueFactoryPtr
Race::StepResult::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::StepResult::ice_staticId());
}

void
Race::_icePatchObjectPtr(StepResultPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::StepResultPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::StepResult::ice_staticId(), v);
    }
}

Race::ServerInitParam::~ServerInitParam()
{
}

::Ice::Object* Race::upCast(::Race::ServerInitParam* p) { return p; }

::Ice::ObjectPtr
Race::ServerInitParam::ice_clone() const
{
    ::Ice::Object* p = new ServerInitParam(*this);
    return p;
}

namespace
{
const ::std::string iceC_Race_ServerInitParam_ids[2] =
{
    "::Ice::Object",
    "::Race::ServerInitParam"
};

}

bool
Race::ServerInitParam::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_ServerInitParam_ids, iceC_Race_ServerInitParam_ids + 2, s);
}

::std::vector< ::std::string>
Race::ServerInitParam::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_ServerInitParam_ids[0], &iceC_Race_ServerInitParam_ids[2]);
}

const ::std::string&
Race::ServerInitParam::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::ServerInitParam::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::ServerInitParam";
    return typeId;
#else
    return iceC_Race_ServerInitParam_ids[1];
#endif
}

void
Race::ServerInitParam::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::ServerInitParam, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::ServerInitParam::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::ServerInitParam, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Race::ServerInitParam> iceC_Race_ServerInitParam_init("::Race::ServerInitParam");
}

::Ice::ValueFactoryPtr
Race::ServerInitParam::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Race::ServerInitParam::ice_staticId());
}

void
Race::_icePatchObjectPtr(ServerInitParamPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::ServerInitParamPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::ServerInitParam::ice_staticId(), v);
    }
}

Race::Pool::~Pool()
{
}

::Ice::Object* Race::upCast(::Race::Pool* p) { return p; }


namespace
{
const ::std::string iceC_Race_Pool_ids[2] =
{
    "::Ice::Object",
    "::Race::Pool"
};

}

bool
Race::Pool::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_Pool_ids, iceC_Race_Pool_ids + 2, s);
}

::std::vector< ::std::string>
Race::Pool::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_Pool_ids[0], &iceC_Race_Pool_ids[2]);
}

const ::std::string&
Race::Pool::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::Pool::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::Pool";
    return typeId;
#else
    return iceC_Race_Pool_ids[1];
#endif
}

bool
Race::Pool::_iceD_onEvent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_evt;
    ::Race::EventParamsPtr iceP_param;
    istr->read(iceP_evt);
    istr->read(iceP_param);
    istr->readPendingValues();
    inS.endReadParams();
    this->onEvent(iceP_evt, iceP_param, current);
    inS.writeEmptyParams();
    return true;
}

bool
Race::Pool::_iceD_predict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Race::StatusList iceP_status;
    istr->read(iceP_status);
    istr->readPendingValues();
    inS.endReadParams();
    ::Race::DriveInfoList ret = this->predict(iceP_status, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

namespace
{
const ::std::string iceC_Race_Pool_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "onEvent",
    "predict"
};

}

bool
Race::Pool::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Race_Pool_all, iceC_Race_Pool_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Race_Pool_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_onEvent(in, current);
        }
        case 5:
        {
            return _iceD_predict(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}

void
Race::Pool::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::Pool, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::Pool::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::Pool, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

void
Race::_icePatchObjectPtr(PoolPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::PoolPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::Pool::ice_staticId(), v);
    }
}

Race::Server::~Server()
{
}

::Ice::Object* Race::upCast(::Race::Server* p) { return p; }


namespace
{
const ::std::string iceC_Race_Server_ids[2] =
{
    "::Ice::Object",
    "::Race::Server"
};

}

bool
Race::Server::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Race_Server_ids, iceC_Race_Server_ids + 2, s);
}

::std::vector< ::std::string>
Race::Server::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Race_Server_ids[0], &iceC_Race_Server_ids[2]);
}

const ::std::string&
Race::Server::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Race::Server::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Race::Server";
    return typeId;
#else
    return iceC_Race_Server_ids[1];
#endif
}

bool
Race::Server::_iceD_init(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Identity iceP_ident;
    ::Race::ServerInitParamPtr iceP_param;
    istr->read(iceP_ident);
    istr->read(iceP_param);
    istr->readPendingValues();
    inS.endReadParams();
    this->init(iceP_ident, iceP_param, current);
    inS.writeEmptyParams();
    return true;
}

bool
Race::Server::_iceD_getBots(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Race::BotInfoList ret = this->getBots(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
Race::Server::_iceD_step(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Race::StepParamPtr iceP_param;
    istr->read(iceP_param);
    istr->readPendingValues();
    inS.endReadParams();
    ::Race::StepResultPtr ret = this->step(iceP_param, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
Race::Server::_iceD_reset(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Race::ResetParamPtr iceP_param;
    istr->read(iceP_param);
    istr->readPendingValues();
    inS.endReadParams();
    ::Race::StepResultPtr ret = this->reset(iceP_param, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
Race::Server::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}

namespace
{
const ::std::string iceC_Race_Server_all[] =
{
    "getBots",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "init",
    "reset",
    "shutdown",
    "step"
};

}

bool
Race::Server::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Race_Server_all, iceC_Race_Server_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Race_Server_all)
    {
        case 0:
        {
            return _iceD_getBots(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_init(in, current);
        }
        case 6:
        {
            return _iceD_reset(in, current);
        }
        case 7:
        {
            return _iceD_shutdown(in, current);
        }
        case 8:
        {
            return _iceD_step(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}

void
Race::Server::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::Race::Server, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Race::Server::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::Race::Server, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

void
Race::_icePatchObjectPtr(ServerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Race::ServerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Race::Server::ice_staticId(), v);
    }
}

namespace Ice
{
}

#endif
