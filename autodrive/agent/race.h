// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `race.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __race_h__
#define __race_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/Identity.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Race
{

class DriveInfo;
class Image;
class Status;
class BotInitParam;
class BotRaceInitParam;
class BotInfo;
class EventParams;
class StepParam;
class ResetParam;
class StepResult;
class ServerInitParam;
class Pool;
class PoolPrx;
class Server;
class ServerPrx;

}

namespace Race
{

using FloatSeq = ::std::vector<float>;

using IntSeq = ::std::vector<int>;

using ByteSeq = ::std::vector<::Ice::Byte>;

using BotInfoList = ::std::vector<::std::shared_ptr<::Race::BotInfo>>;

using StatusList = ::std::vector<::std::shared_ptr<::Race::Status>>;

using DriveInfoList = ::std::vector<::std::shared_ptr<::Race::DriveInfo>>;

using BotRaceInitParamList = ::std::vector<::std::shared_ptr<::Race::BotRaceInitParam>>;

}

namespace Race
{

class Pool : public virtual ::Ice::Object
{
public:

    using ProxyType = PoolPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual void onEvent(::std::string, ::std::shared_ptr<::Race::EventParams>, const ::Ice::Current&) = 0;
    bool _iceD_onEvent(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Race::DriveInfoList predict(::Race::StatusList, const ::Ice::Current&) = 0;
    bool _iceD_predict(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class Server : public virtual ::Ice::Object
{
public:

    using ProxyType = ServerPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual void init(::Ice::Identity, ::std::shared_ptr<::Race::ServerInitParam>, const ::Ice::Current&) = 0;
    bool _iceD_init(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Race::BotInfoList getBots(const ::Ice::Current&) = 0;
    bool _iceD_getBots(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::shared_ptr<::Race::StepResult> step(::std::shared_ptr<::Race::StepParam>, const ::Ice::Current&) = 0;
    bool _iceD_step(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::shared_ptr<::Race::StepResult> reset(::std::shared_ptr<::Race::ResetParam>, const ::Ice::Current&) = 0;
    bool _iceD_reset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void shutdown(const ::Ice::Current&) = 0;
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

}

namespace Race
{

class DriveInfo : public ::Ice::ValueHelper<DriveInfo, Ice::Value>
{
public:

    virtual ~DriveInfo();

    DriveInfo() = default;

    DriveInfo(const DriveInfo&) = default;
    DriveInfo(DriveInfo&&) = default;
    DriveInfo& operator=(const DriveInfo&) = default;
    DriveInfo& operator=(DriveInfo&&) = default;

    DriveInfo(int iceP_ident, long long int iceP_seqIdx, float iceP_steering, float iceP_acceleration, float iceP_brake, float iceP_clutch, int iceP_focus, int iceP_gear) :
        ident(iceP_ident),
        seqIdx(iceP_seqIdx),
        steering(iceP_steering),
        acceleration(iceP_acceleration),
        brake(iceP_brake),
        clutch(iceP_clutch),
        focus(iceP_focus),
        gear(iceP_gear)
    {
    }

    std::tuple<const int&, const long long int&, const float&, const float&, const float&, const float&, const int&, const int&> ice_tuple() const
    {
        return std::tie(ident, seqIdx, steering, acceleration, brake, clutch, focus, gear);
    }

    static const ::std::string& ice_staticId();

    int ident = -1;
    long long int seqIdx = -1LL;
    float steering = 0.0F;
    float acceleration = 0.0F;
    float brake = 0.0F;
    float clutch = 0.0F;
    int focus = 0;
    int gear = 0;
};

static DriveInfo _iceS_DriveInfo_init;

class Image : public ::Ice::ValueHelper<Image, Ice::Value>
{
public:

    virtual ~Image();

    Image() = default;

    Image(const Image&) = default;
    Image(Image&&) = default;
    Image& operator=(const Image&) = default;
    Image& operator=(Image&&) = default;

    Image(int iceP_width, int iceP_height, const ::Race::ByteSeq& iceP_data) :
        width(iceP_width),
        height(iceP_height),
        data(::std::move(iceP_data))
    {
    }

    std::tuple<const int&, const int&, const ::Race::ByteSeq&> ice_tuple() const
    {
        return std::tie(width, height, data);
    }

    static const ::std::string& ice_staticId();

    int width;
    int height;
    ::Race::ByteSeq data;
};

class Status : public ::Ice::ValueHelper<Status, Ice::Value>
{
public:

    virtual ~Status();

    Status() = default;

    Status(const Status&) = default;
    Status(Status&&) = default;
    Status& operator=(const Status&) = default;
    Status& operator=(Status&&) = default;

    Status(int iceP_ident, long long int iceP_seqIdx, float iceP_angle, float iceP_curLapTime, float iceP_damage, float iceP_distFromStart, float iceP_distRaced, float iceP_fuel, int iceP_gear, float iceP_lastLapTime, const ::Race::FloatSeq& iceP_opponents, int iceP_racePos, float iceP_rpm, float iceP_speedX, float iceP_speedY, float iceP_speedZ, const ::Race::FloatSeq& iceP_track, float iceP_trackPos, const ::Race::FloatSeq& iceP_wheelSpinVel, float iceP_z, const ::Race::FloatSeq& iceP_focus, int iceP_laps, const ::std::shared_ptr<::Race::DriveInfo>& iceP_driveInfo, const ::std::shared_ptr<::Race::Image>& iceP_image, bool iceP_isOver) :
        ident(iceP_ident),
        seqIdx(iceP_seqIdx),
        angle(iceP_angle),
        curLapTime(iceP_curLapTime),
        damage(iceP_damage),
        distFromStart(iceP_distFromStart),
        distRaced(iceP_distRaced),
        fuel(iceP_fuel),
        gear(iceP_gear),
        lastLapTime(iceP_lastLapTime),
        opponents(::std::move(iceP_opponents)),
        racePos(iceP_racePos),
        rpm(iceP_rpm),
        speedX(iceP_speedX),
        speedY(iceP_speedY),
        speedZ(iceP_speedZ),
        track(::std::move(iceP_track)),
        trackPos(iceP_trackPos),
        wheelSpinVel(::std::move(iceP_wheelSpinVel)),
        z(iceP_z),
        focus(::std::move(iceP_focus)),
        laps(iceP_laps),
        driveInfo(::std::move(iceP_driveInfo)),
        image(::std::move(iceP_image)),
        isOver(iceP_isOver)
    {
    }

    std::tuple<const int&, const long long int&, const float&, const float&, const float&, const float&, const float&, const float&, const int&, const float&, const ::Race::FloatSeq&, const int&, const float&, const float&, const float&, const float&, const ::Race::FloatSeq&, const float&, const ::Race::FloatSeq&, const float&, const ::Race::FloatSeq&, const int&, const ::std::shared_ptr<::Race::DriveInfo>&, const ::std::shared_ptr<::Race::Image>&, const bool&> ice_tuple() const
    {
        return std::tie(ident, seqIdx, angle, curLapTime, damage, distFromStart, distRaced, fuel, gear, lastLapTime, opponents, racePos, rpm, speedX, speedY, speedZ, track, trackPos, wheelSpinVel, z, focus, laps, driveInfo, image, isOver);
    }

    static const ::std::string& ice_staticId();

    int ident = -1;
    long long int seqIdx = -1LL;
    float angle = 0.0F;
    float curLapTime = 0.0F;
    float damage = 0.0F;
    float distFromStart = 0.0F;
    float distRaced = 0.0F;
    float fuel = 0.0F;
    int gear = 0;
    float lastLapTime = 0.0F;
    ::Race::FloatSeq opponents;
    int racePos = 0;
    float rpm = 0.0F;
    float speedX = 0.0F;
    float speedY = 0.0F;
    float speedZ = 0.0F;
    ::Race::FloatSeq track;
    float trackPos = 0.0F;
    ::Race::FloatSeq wheelSpinVel;
    float z = 0.0F;
    ::Race::FloatSeq focus;
    int laps = 0;
    ::std::shared_ptr<::Race::DriveInfo> driveInfo;
    ::std::shared_ptr<::Race::Image> image;
    bool isOver = false;
};

class BotInitParam : public ::Ice::ValueHelper<BotInitParam, Ice::Value>
{
public:

    virtual ~BotInitParam();

    BotInitParam() = default;

    BotInitParam(const BotInitParam&) = default;
    BotInitParam(BotInitParam&&) = default;
    BotInitParam& operator=(const BotInitParam&) = default;
    BotInitParam& operator=(BotInitParam&&) = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

class BotRaceInitParam : public ::Ice::ValueHelper<BotRaceInitParam, Ice::Value>
{
public:

    virtual ~BotRaceInitParam();

    BotRaceInitParam() = default;

    BotRaceInitParam(const BotRaceInitParam&) = default;
    BotRaceInitParam(BotRaceInitParam&&) = default;
    BotRaceInitParam& operator=(const BotRaceInitParam&) = default;
    BotRaceInitParam& operator=(BotRaceInitParam&&) = default;

    BotRaceInitParam(int iceP_ident, const ::Race::FloatSeq& iceP_angles, bool iceP_screenCapture) :
        ident(iceP_ident),
        angles(::std::move(iceP_angles)),
        screenCapture(iceP_screenCapture)
    {
    }

    std::tuple<const int&, const ::Race::FloatSeq&, const bool&> ice_tuple() const
    {
        return std::tie(ident, angles, screenCapture);
    }

    static const ::std::string& ice_staticId();

    int ident = -1;
    ::Race::FloatSeq angles;
    bool screenCapture = false;
};

class BotInfo : public ::Ice::ValueHelper<BotInfo, Ice::Value>
{
public:

    virtual ~BotInfo();

    BotInfo() = default;

    BotInfo(const BotInfo&) = default;
    BotInfo(BotInfo&&) = default;
    BotInfo& operator=(const BotInfo&) = default;
    BotInfo& operator=(BotInfo&&) = default;

    BotInfo(int iceP_idx, const ::std::string& iceP_name) :
        idx(iceP_idx),
        name(::std::move(iceP_name))
    {
    }

    std::tuple<const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(idx, name);
    }

    static const ::std::string& ice_staticId();

    int idx;
    ::std::string name;
};

class EventParams : public ::Ice::ValueHelper<EventParams, Ice::Value>
{
public:

    virtual ~EventParams();

    EventParams() = default;

    EventParams(const EventParams&) = default;
    EventParams(EventParams&&) = default;
    EventParams& operator=(const EventParams&) = default;
    EventParams& operator=(EventParams&&) = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

class StepParam : public ::Ice::ValueHelper<StepParam, Ice::Value>
{
public:

    virtual ~StepParam();

    StepParam() = default;

    StepParam(const StepParam&) = default;
    StepParam(StepParam&&) = default;
    StepParam& operator=(const StepParam&) = default;
    StepParam& operator=(StepParam&&) = default;

    explicit StepParam(const ::Race::DriveInfoList& iceP_driveInfos) :
        driveInfos(::std::move(iceP_driveInfos))
    {
    }

    std::tuple<const ::Race::DriveInfoList&> ice_tuple() const
    {
        return std::tie(driveInfos);
    }

    static const ::std::string& ice_staticId();

    ::Race::DriveInfoList driveInfos;
};

class ResetParam : public ::Ice::ValueHelper<ResetParam, Ice::Value>
{
public:

    virtual ~ResetParam();

    ResetParam() = default;

    ResetParam(const ResetParam&) = default;
    ResetParam(ResetParam&&) = default;
    ResetParam& operator=(const ResetParam&) = default;
    ResetParam& operator=(ResetParam&&) = default;

    explicit ResetParam(const ::Race::BotRaceInitParamList& iceP_raceInit) :
        raceInit(::std::move(iceP_raceInit))
    {
    }

    std::tuple<const ::Race::BotRaceInitParamList&> ice_tuple() const
    {
        return std::tie(raceInit);
    }

    static const ::std::string& ice_staticId();

    ::Race::BotRaceInitParamList raceInit;
};

class StepResult : public ::Ice::ValueHelper<StepResult, Ice::Value>
{
public:

    virtual ~StepResult();

    StepResult() = default;

    StepResult(const StepResult&) = default;
    StepResult(StepResult&&) = default;
    StepResult& operator=(const StepResult&) = default;
    StepResult& operator=(StepResult&&) = default;

    StepResult(const ::Race::StatusList& iceP_statusList, bool iceP_isOver, bool iceP_isAllFinished) :
        statusList(::std::move(iceP_statusList)),
        isOver(iceP_isOver),
        isAllFinished(iceP_isAllFinished)
    {
    }

    std::tuple<const ::Race::StatusList&, const bool&, const bool&> ice_tuple() const
    {
        return std::tie(statusList, isOver, isAllFinished);
    }

    static const ::std::string& ice_staticId();

    ::Race::StatusList statusList;
    bool isOver = false;
    bool isAllFinished = false;
};

class ServerInitParam : public ::Ice::ValueHelper<ServerInitParam, Ice::Value>
{
public:

    virtual ~ServerInitParam();

    ServerInitParam() = default;

    ServerInitParam(const ServerInitParam&) = default;
    ServerInitParam(ServerInitParam&&) = default;
    ServerInitParam& operator=(const ServerInitParam&) = default;
    ServerInitParam& operator=(ServerInitParam&&) = default;

    ServerInitParam(const ::std::string& iceP_dataioHost, int iceP_dataioPort, const ::std::string& iceP_name, float iceP_timeMult) :
        dataioHost(::std::move(iceP_dataioHost)),
        dataioPort(iceP_dataioPort),
        name(::std::move(iceP_name)),
        timeMult(iceP_timeMult)
    {
    }

    std::tuple<const ::std::string&, const int&, const ::std::string&, const float&> ice_tuple() const
    {
        return std::tie(dataioHost, dataioPort, name, timeMult);
    }

    static const ::std::string& ice_staticId();

    ::std::string dataioHost;
    int dataioPort;
    ::std::string name;
    float timeMult = 1.0F;
};

}

namespace Race
{

class PoolPrx : public virtual ::Ice::Proxy<PoolPrx, ::Ice::ObjectPrx>
{
public:

    void onEvent(const ::std::string& iceP_evt, const ::std::shared_ptr<::Race::EventParams>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Race::PoolPrx::_iceI_onEvent, iceP_evt, iceP_param, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto onEventAsync(const ::std::string& iceP_evt, const ::std::shared_ptr<::Race::EventParams>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Race::PoolPrx::_iceI_onEvent, iceP_evt, iceP_param, context);
    }

    ::std::function<void()>
    onEventAsync(const ::std::string& iceP_evt, const ::std::shared_ptr<::Race::EventParams>& iceP_param,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Race::PoolPrx::_iceI_onEvent, iceP_evt, iceP_param, context);
    }

    void _iceI_onEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::shared_ptr<::Race::EventParams>&, const ::Ice::Context&);

    ::Race::DriveInfoList predict(const ::Race::StatusList& iceP_status, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Race::DriveInfoList>(true, this, &Race::PoolPrx::_iceI_predict, iceP_status, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto predictAsync(const ::Race::StatusList& iceP_status, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Race::DriveInfoList>>().get_future())
    {
        return _makePromiseOutgoing<::Race::DriveInfoList, P>(false, this, &Race::PoolPrx::_iceI_predict, iceP_status, context);
    }

    ::std::function<void()>
    predictAsync(const ::Race::StatusList& iceP_status,
                 ::std::function<void(::Race::DriveInfoList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Race::DriveInfoList>(response, ex, sent, this, &Race::PoolPrx::_iceI_predict, iceP_status, context);
    }

    void _iceI_predict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Race::DriveInfoList>>&, const ::Race::StatusList&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    PoolPrx() = default;
    friend ::std::shared_ptr<PoolPrx> IceInternal::createProxy<PoolPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class ServerPrx : public virtual ::Ice::Proxy<ServerPrx, ::Ice::ObjectPrx>
{
public:

    void init(const ::Ice::Identity& iceP_ident, const ::std::shared_ptr<::Race::ServerInitParam>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Race::ServerPrx::_iceI_init, iceP_ident, iceP_param, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto initAsync(const ::Ice::Identity& iceP_ident, const ::std::shared_ptr<::Race::ServerInitParam>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Race::ServerPrx::_iceI_init, iceP_ident, iceP_param, context);
    }

    ::std::function<void()>
    initAsync(const ::Ice::Identity& iceP_ident, const ::std::shared_ptr<::Race::ServerInitParam>& iceP_param,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Race::ServerPrx::_iceI_init, iceP_ident, iceP_param, context);
    }

    void _iceI_init(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Identity&, const ::std::shared_ptr<::Race::ServerInitParam>&, const ::Ice::Context&);

    ::Race::BotInfoList getBots(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Race::BotInfoList>(true, this, &Race::ServerPrx::_iceI_getBots, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getBotsAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Race::BotInfoList>>().get_future())
    {
        return _makePromiseOutgoing<::Race::BotInfoList, P>(false, this, &Race::ServerPrx::_iceI_getBots, context);
    }

    ::std::function<void()>
    getBotsAsync(::std::function<void(::Race::BotInfoList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Race::BotInfoList>(response, ex, sent, this, &Race::ServerPrx::_iceI_getBots, context);
    }

    void _iceI_getBots(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Race::BotInfoList>>&, const ::Ice::Context&);

    ::std::shared_ptr<::Race::StepResult> step(const ::std::shared_ptr<::Race::StepParam>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Race::StepResult>>(true, this, &Race::ServerPrx::_iceI_step, iceP_param, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto stepAsync(const ::std::shared_ptr<::Race::StepParam>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Race::StepResult>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Race::StepResult>, P>(false, this, &Race::ServerPrx::_iceI_step, iceP_param, context);
    }

    ::std::function<void()>
    stepAsync(const ::std::shared_ptr<::Race::StepParam>& iceP_param,
              ::std::function<void(::std::shared_ptr<::Race::StepResult>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Race::StepResult>>(response, ex, sent, this, &Race::ServerPrx::_iceI_step, iceP_param, context);
    }

    void _iceI_step(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Race::StepResult>>>&, const ::std::shared_ptr<::Race::StepParam>&, const ::Ice::Context&);

    ::std::shared_ptr<::Race::StepResult> reset(const ::std::shared_ptr<::Race::ResetParam>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Race::StepResult>>(true, this, &Race::ServerPrx::_iceI_reset, iceP_param, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto resetAsync(const ::std::shared_ptr<::Race::ResetParam>& iceP_param, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Race::StepResult>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Race::StepResult>, P>(false, this, &Race::ServerPrx::_iceI_reset, iceP_param, context);
    }

    ::std::function<void()>
    resetAsync(const ::std::shared_ptr<::Race::ResetParam>& iceP_param,
               ::std::function<void(::std::shared_ptr<::Race::StepResult>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Race::StepResult>>(response, ex, sent, this, &Race::ServerPrx::_iceI_reset, iceP_param, context);
    }

    void _iceI_reset(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Race::StepResult>>>&, const ::std::shared_ptr<::Race::ResetParam>&, const ::Ice::Context&);

    void shutdown(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Race::ServerPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Race::ServerPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Race::ServerPrx::_iceI_shutdown, context);
    }

    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    ServerPrx() = default;
    friend ::std::shared_ptr<ServerPrx> IceInternal::createProxy<ServerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

}

namespace Ice
{

template<typename S>
struct StreamReader<::Race::DriveInfo, S>
{
    static void read(S* istr, ::Race::DriveInfo& v)
    {
        istr->readAll(v.ident, v.seqIdx, v.steering, v.acceleration, v.brake, v.clutch, v.focus, v.gear);
    }
};

template<typename S>
struct StreamReader<::Race::Image, S>
{
    static void read(S* istr, ::Race::Image& v)
    {
        istr->readAll(v.width, v.height, v.data);
    }
};

template<typename S>
struct StreamReader<::Race::Status, S>
{
    static void read(S* istr, ::Race::Status& v)
    {
        istr->readAll(v.ident, v.seqIdx, v.angle, v.curLapTime, v.damage, v.distFromStart, v.distRaced, v.fuel, v.gear, v.lastLapTime, v.opponents, v.racePos, v.rpm, v.speedX, v.speedY, v.speedZ, v.track, v.trackPos, v.wheelSpinVel, v.z, v.focus, v.laps, v.driveInfo, v.image, v.isOver);
    }
};

template<typename S>
struct StreamReader<::Race::BotRaceInitParam, S>
{
    static void read(S* istr, ::Race::BotRaceInitParam& v)
    {
        istr->readAll(v.ident, v.angles, v.screenCapture);
    }
};

template<typename S>
struct StreamReader<::Race::BotInfo, S>
{
    static void read(S* istr, ::Race::BotInfo& v)
    {
        istr->readAll(v.idx, v.name);
    }
};

template<typename S>
struct StreamReader<::Race::StepParam, S>
{
    static void read(S* istr, ::Race::StepParam& v)
    {
        istr->readAll(v.driveInfos);
    }
};

template<typename S>
struct StreamReader<::Race::ResetParam, S>
{
    static void read(S* istr, ::Race::ResetParam& v)
    {
        istr->readAll(v.raceInit);
    }
};

template<typename S>
struct StreamReader<::Race::StepResult, S>
{
    static void read(S* istr, ::Race::StepResult& v)
    {
        istr->readAll(v.statusList, v.isOver, v.isAllFinished);
    }
};

template<typename S>
struct StreamReader<::Race::ServerInitParam, S>
{
    static void read(S* istr, ::Race::ServerInitParam& v)
    {
        istr->readAll(v.dataioHost, v.dataioPort, v.name, v.timeMult);
    }
};

}

namespace Race
{

using DriveInfoPtr = ::std::shared_ptr<DriveInfo>;

using ImagePtr = ::std::shared_ptr<Image>;

using StatusPtr = ::std::shared_ptr<Status>;

using BotInitParamPtr = ::std::shared_ptr<BotInitParam>;

using BotRaceInitParamPtr = ::std::shared_ptr<BotRaceInitParam>;

using BotInfoPtr = ::std::shared_ptr<BotInfo>;

using EventParamsPtr = ::std::shared_ptr<EventParams>;

using StepParamPtr = ::std::shared_ptr<StepParam>;

using ResetParamPtr = ::std::shared_ptr<ResetParam>;

using StepResultPtr = ::std::shared_ptr<StepResult>;

using ServerInitParamPtr = ::std::shared_ptr<ServerInitParam>;

using PoolPtr = ::std::shared_ptr<Pool>;
using PoolPrxPtr = ::std::shared_ptr<PoolPrx>;

using ServerPtr = ::std::shared_ptr<Server>;
using ServerPrxPtr = ::std::shared_ptr<ServerPrx>;

}

#else // C++98 mapping

namespace IceProxy
{

namespace Race
{

class DriveInfo;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::DriveInfo>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::DriveInfo*);

class Image;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::Image>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::Image*);

class Status;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::Status>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::Status*);

class BotInitParam;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::BotInitParam>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::BotInitParam*);

class BotRaceInitParam;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::BotRaceInitParam>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::BotRaceInitParam*);

class BotInfo;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::BotInfo>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::BotInfo*);

class EventParams;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::EventParams>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::EventParams*);

class StepParam;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::StepParam>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::StepParam*);

class ResetParam;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::ResetParam>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::ResetParam*);

class StepResult;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::StepResult>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::StepResult*);

class ServerInitParam;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::ServerInitParam>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::ServerInitParam*);

class Pool;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::Pool>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::Pool*);

class Server;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Race::Server>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Race::Server*);

}

}

namespace Race
{

class DriveInfo;
::Ice::Object* upCast(::Race::DriveInfo*);
typedef ::IceInternal::Handle< ::Race::DriveInfo> DriveInfoPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::DriveInfo> DriveInfoPrx;
typedef DriveInfoPrx DriveInfoPrxPtr;
void _icePatchObjectPtr(DriveInfoPtr&, const ::Ice::ObjectPtr&);

class Image;
::Ice::Object* upCast(::Race::Image*);
typedef ::IceInternal::Handle< ::Race::Image> ImagePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::Image> ImagePrx;
typedef ImagePrx ImagePrxPtr;
void _icePatchObjectPtr(ImagePtr&, const ::Ice::ObjectPtr&);

class Status;
::Ice::Object* upCast(::Race::Status*);
typedef ::IceInternal::Handle< ::Race::Status> StatusPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::Status> StatusPrx;
typedef StatusPrx StatusPrxPtr;
void _icePatchObjectPtr(StatusPtr&, const ::Ice::ObjectPtr&);

class BotInitParam;
::Ice::Object* upCast(::Race::BotInitParam*);
typedef ::IceInternal::Handle< ::Race::BotInitParam> BotInitParamPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::BotInitParam> BotInitParamPrx;
typedef BotInitParamPrx BotInitParamPrxPtr;
void _icePatchObjectPtr(BotInitParamPtr&, const ::Ice::ObjectPtr&);

class BotRaceInitParam;
::Ice::Object* upCast(::Race::BotRaceInitParam*);
typedef ::IceInternal::Handle< ::Race::BotRaceInitParam> BotRaceInitParamPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::BotRaceInitParam> BotRaceInitParamPrx;
typedef BotRaceInitParamPrx BotRaceInitParamPrxPtr;
void _icePatchObjectPtr(BotRaceInitParamPtr&, const ::Ice::ObjectPtr&);

class BotInfo;
::Ice::Object* upCast(::Race::BotInfo*);
typedef ::IceInternal::Handle< ::Race::BotInfo> BotInfoPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::BotInfo> BotInfoPrx;
typedef BotInfoPrx BotInfoPrxPtr;
void _icePatchObjectPtr(BotInfoPtr&, const ::Ice::ObjectPtr&);

class EventParams;
::Ice::Object* upCast(::Race::EventParams*);
typedef ::IceInternal::Handle< ::Race::EventParams> EventParamsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::EventParams> EventParamsPrx;
typedef EventParamsPrx EventParamsPrxPtr;
void _icePatchObjectPtr(EventParamsPtr&, const ::Ice::ObjectPtr&);

class StepParam;
::Ice::Object* upCast(::Race::StepParam*);
typedef ::IceInternal::Handle< ::Race::StepParam> StepParamPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::StepParam> StepParamPrx;
typedef StepParamPrx StepParamPrxPtr;
void _icePatchObjectPtr(StepParamPtr&, const ::Ice::ObjectPtr&);

class ResetParam;
::Ice::Object* upCast(::Race::ResetParam*);
typedef ::IceInternal::Handle< ::Race::ResetParam> ResetParamPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::ResetParam> ResetParamPrx;
typedef ResetParamPrx ResetParamPrxPtr;
void _icePatchObjectPtr(ResetParamPtr&, const ::Ice::ObjectPtr&);

class StepResult;
::Ice::Object* upCast(::Race::StepResult*);
typedef ::IceInternal::Handle< ::Race::StepResult> StepResultPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::StepResult> StepResultPrx;
typedef StepResultPrx StepResultPrxPtr;
void _icePatchObjectPtr(StepResultPtr&, const ::Ice::ObjectPtr&);

class ServerInitParam;
::Ice::Object* upCast(::Race::ServerInitParam*);
typedef ::IceInternal::Handle< ::Race::ServerInitParam> ServerInitParamPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::ServerInitParam> ServerInitParamPrx;
typedef ServerInitParamPrx ServerInitParamPrxPtr;
void _icePatchObjectPtr(ServerInitParamPtr&, const ::Ice::ObjectPtr&);

class Pool;
::Ice::Object* upCast(::Race::Pool*);
typedef ::IceInternal::Handle< ::Race::Pool> PoolPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::Pool> PoolPrx;
typedef PoolPrx PoolPrxPtr;
void _icePatchObjectPtr(PoolPtr&, const ::Ice::ObjectPtr&);

class Server;
::Ice::Object* upCast(::Race::Server*);
typedef ::IceInternal::Handle< ::Race::Server> ServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Race::Server> ServerPrx;
typedef ServerPrx ServerPrxPtr;
void _icePatchObjectPtr(ServerPtr&, const ::Ice::ObjectPtr&);

}

namespace Race
{

typedef ::std::vector< ::Ice::Float> FloatSeq;

typedef ::std::vector< ::Ice::Int> IntSeq;

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef ::std::vector< ::Race::BotInfoPtr> BotInfoList;

typedef ::std::vector< ::Race::StatusPtr> StatusList;

typedef ::std::vector< ::Race::DriveInfoPtr> DriveInfoList;

typedef ::std::vector< ::Race::BotRaceInitParamPtr> BotRaceInitParamList;

}

namespace Race
{

class Callback_Pool_onEvent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Pool_onEvent_Base> Callback_Pool_onEventPtr;

class Callback_Pool_predict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Pool_predict_Base> Callback_Pool_predictPtr;

class Callback_Server_init_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_init_Base> Callback_Server_initPtr;

class Callback_Server_getBots_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_getBots_Base> Callback_Server_getBotsPtr;

class Callback_Server_step_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_step_Base> Callback_Server_stepPtr;

class Callback_Server_reset_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_reset_Base> Callback_Server_resetPtr;

class Callback_Server_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Server_shutdown_Base> Callback_Server_shutdownPtr;

}

namespace IceProxy
{

namespace Race
{

class DriveInfo : public virtual ::Ice::Proxy<DriveInfo, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class Image : public virtual ::Ice::Proxy<Image, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class Status : public virtual ::Ice::Proxy<Status, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class BotInitParam : public virtual ::Ice::Proxy<BotInitParam, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class BotRaceInitParam : public virtual ::Ice::Proxy<BotRaceInitParam, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class BotInfo : public virtual ::Ice::Proxy<BotInfo, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class EventParams : public virtual ::Ice::Proxy<EventParams, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class StepParam : public virtual ::Ice::Proxy<StepParam, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class ResetParam : public virtual ::Ice::Proxy<ResetParam, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class StepResult : public virtual ::Ice::Proxy<StepResult, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class ServerInitParam : public virtual ::Ice::Proxy<ServerInitParam, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class Pool : public virtual ::Ice::Proxy<Pool, ::IceProxy::Ice::Object>
{
public:

    void onEvent(const ::std::string& iceP_evt, const ::Race::EventParamsPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_onEvent(_iceI_begin_onEvent(iceP_evt, iceP_param, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::std::string& iceP_evt, const ::Race::EventParamsPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_onEvent(iceP_evt, iceP_param, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::std::string& iceP_evt, const ::Race::EventParamsPtr& iceP_param, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onEvent(iceP_evt, iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::std::string& iceP_evt, const ::Race::EventParamsPtr& iceP_param, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onEvent(iceP_evt, iceP_param, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::std::string& iceP_evt, const ::Race::EventParamsPtr& iceP_param, const ::Race::Callback_Pool_onEventPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onEvent(iceP_evt, iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_onEvent(const ::std::string& iceP_evt, const ::Race::EventParamsPtr& iceP_param, const ::Ice::Context& context, const ::Race::Callback_Pool_onEventPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onEvent(iceP_evt, iceP_param, context, del, cookie);
    }

    void end_onEvent(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_onEvent(const ::std::string&, const ::Race::EventParamsPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Race::DriveInfoList predict(const ::Race::StatusList& iceP_status, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_predict(_iceI_begin_predict(iceP_status, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_predict(const ::Race::StatusList& iceP_status, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_predict(iceP_status, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_predict(const ::Race::StatusList& iceP_status, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_predict(iceP_status, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_predict(const ::Race::StatusList& iceP_status, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_predict(iceP_status, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_predict(const ::Race::StatusList& iceP_status, const ::Race::Callback_Pool_predictPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_predict(iceP_status, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_predict(const ::Race::StatusList& iceP_status, const ::Ice::Context& context, const ::Race::Callback_Pool_predictPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_predict(iceP_status, context, del, cookie);
    }

    ::Race::DriveInfoList end_predict(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_predict(const ::Race::StatusList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class Server : public virtual ::Ice::Proxy<Server, ::IceProxy::Ice::Object>
{
public:

    void init(const ::Ice::Identity& iceP_ident, const ::Race::ServerInitParamPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_init(_iceI_begin_init(iceP_ident, iceP_param, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_init(const ::Ice::Identity& iceP_ident, const ::Race::ServerInitParamPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_init(iceP_ident, iceP_param, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_init(const ::Ice::Identity& iceP_ident, const ::Race::ServerInitParamPtr& iceP_param, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(iceP_ident, iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::Ice::Identity& iceP_ident, const ::Race::ServerInitParamPtr& iceP_param, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(iceP_ident, iceP_param, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::Ice::Identity& iceP_ident, const ::Race::ServerInitParamPtr& iceP_param, const ::Race::Callback_Server_initPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(iceP_ident, iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::Ice::Identity& iceP_ident, const ::Race::ServerInitParamPtr& iceP_param, const ::Ice::Context& context, const ::Race::Callback_Server_initPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(iceP_ident, iceP_param, context, del, cookie);
    }

    void end_init(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_init(const ::Ice::Identity&, const ::Race::ServerInitParamPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Race::BotInfoList getBots(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getBots(_iceI_begin_getBots(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getBots(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getBots(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBots(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBots(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBots(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBots(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBots(const ::Race::Callback_Server_getBotsPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBots(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getBots(const ::Ice::Context& context, const ::Race::Callback_Server_getBotsPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getBots(context, del, cookie);
    }

    ::Race::BotInfoList end_getBots(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getBots(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Race::StepResultPtr step(const ::Race::StepParamPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_step(_iceI_begin_step(iceP_param, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_step(const ::Race::StepParamPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_step(iceP_param, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_step(const ::Race::StepParamPtr& iceP_param, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_step(iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_step(const ::Race::StepParamPtr& iceP_param, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_step(iceP_param, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_step(const ::Race::StepParamPtr& iceP_param, const ::Race::Callback_Server_stepPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_step(iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_step(const ::Race::StepParamPtr& iceP_param, const ::Ice::Context& context, const ::Race::Callback_Server_stepPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_step(iceP_param, context, del, cookie);
    }

    ::Race::StepResultPtr end_step(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_step(const ::Race::StepParamPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Race::StepResultPtr reset(const ::Race::ResetParamPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_reset(_iceI_begin_reset(iceP_param, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_reset(const ::Race::ResetParamPtr& iceP_param, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_reset(iceP_param, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reset(const ::Race::ResetParamPtr& iceP_param, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reset(iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_reset(const ::Race::ResetParamPtr& iceP_param, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reset(iceP_param, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_reset(const ::Race::ResetParamPtr& iceP_param, const ::Race::Callback_Server_resetPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reset(iceP_param, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_reset(const ::Race::ResetParamPtr& iceP_param, const ::Ice::Context& context, const ::Race::Callback_Server_resetPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reset(iceP_param, context, del, cookie);
    }

    ::Race::StepResultPtr end_reset(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_reset(const ::Race::ResetParamPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Race::Callback_Server_shutdownPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Race::Callback_Server_shutdownPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, del, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

}

}

namespace Race
{

class DriveInfo : public virtual ::Ice::Object
{
public:

    typedef DriveInfoPrx ProxyType;
    typedef DriveInfoPtr PointerType;

    virtual ~DriveInfo();

    DriveInfo() :
        ident(-1),
        seqIdx(ICE_INT64(-1)),
        steering(0.0F),
        acceleration(0.0F),
        brake(0.0F),
        clutch(0.0F),
        focus(0),
        gear(0)
    {
    }

    DriveInfo(::Ice::Int iceP_ident, ::Ice::Long iceP_seqIdx, ::Ice::Float iceP_steering, ::Ice::Float iceP_acceleration, ::Ice::Float iceP_brake, ::Ice::Float iceP_clutch, ::Ice::Int iceP_focus, ::Ice::Int iceP_gear) :
        ident(iceP_ident),
        seqIdx(iceP_seqIdx),
        steering(iceP_steering),
        acceleration(iceP_acceleration),
        brake(iceP_brake),
        clutch(iceP_clutch),
        focus(iceP_focus),
        gear(iceP_gear)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int ident;
    ::Ice::Long seqIdx;
    ::Ice::Float steering;
    ::Ice::Float acceleration;
    ::Ice::Float brake;
    ::Ice::Float clutch;
    ::Ice::Int focus;
    ::Ice::Int gear;
};
static ::Ice::ValueFactoryPtr _iceS_DriveInfo_init = ::Race::DriveInfo::ice_factory();

inline bool operator==(const DriveInfo& lhs, const DriveInfo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const DriveInfo& lhs, const DriveInfo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class Image : public virtual ::Ice::Object
{
public:

    typedef ImagePrx ProxyType;
    typedef ImagePtr PointerType;

    virtual ~Image();

    Image()
    {
    }

    Image(::Ice::Int iceP_width, ::Ice::Int iceP_height, const ::Race::ByteSeq& iceP_data) :
        width(iceP_width),
        height(iceP_height),
        data(iceP_data)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int width;
    ::Ice::Int height;
    ::Race::ByteSeq data;
};
static ::Ice::ValueFactoryPtr _iceS_Image_init = ::Race::Image::ice_factory();

inline bool operator==(const Image& lhs, const Image& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Image& lhs, const Image& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class Status : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef StatusPrx ProxyType;
    typedef StatusPtr PointerType;

    virtual ~Status();

    Status() :
        ident(-1),
        seqIdx(ICE_INT64(-1)),
        angle(0.0F),
        curLapTime(0.0F),
        damage(0.0F),
        distFromStart(0.0F),
        distRaced(0.0F),
        fuel(0.0F),
        gear(0),
        lastLapTime(0.0F),
        racePos(0),
        rpm(0.0F),
        speedX(0.0F),
        speedY(0.0F),
        speedZ(0.0F),
        trackPos(0.0F),
        z(0.0F),
        laps(0),
        isOver(false)
    {
    }

    Status(::Ice::Int iceP_ident, ::Ice::Long iceP_seqIdx, ::Ice::Float iceP_angle, ::Ice::Float iceP_curLapTime, ::Ice::Float iceP_damage, ::Ice::Float iceP_distFromStart, ::Ice::Float iceP_distRaced, ::Ice::Float iceP_fuel, ::Ice::Int iceP_gear, ::Ice::Float iceP_lastLapTime, const ::Race::FloatSeq& iceP_opponents, ::Ice::Int iceP_racePos, ::Ice::Float iceP_rpm, ::Ice::Float iceP_speedX, ::Ice::Float iceP_speedY, ::Ice::Float iceP_speedZ, const ::Race::FloatSeq& iceP_track, ::Ice::Float iceP_trackPos, const ::Race::FloatSeq& iceP_wheelSpinVel, ::Ice::Float iceP_z, const ::Race::FloatSeq& iceP_focus, ::Ice::Int iceP_laps, const ::Race::DriveInfoPtr& iceP_driveInfo, const ::Race::ImagePtr& iceP_image, bool iceP_isOver) :
        ident(iceP_ident),
        seqIdx(iceP_seqIdx),
        angle(iceP_angle),
        curLapTime(iceP_curLapTime),
        damage(iceP_damage),
        distFromStart(iceP_distFromStart),
        distRaced(iceP_distRaced),
        fuel(iceP_fuel),
        gear(iceP_gear),
        lastLapTime(iceP_lastLapTime),
        opponents(iceP_opponents),
        racePos(iceP_racePos),
        rpm(iceP_rpm),
        speedX(iceP_speedX),
        speedY(iceP_speedY),
        speedZ(iceP_speedZ),
        track(iceP_track),
        trackPos(iceP_trackPos),
        wheelSpinVel(iceP_wheelSpinVel),
        z(iceP_z),
        focus(iceP_focus),
        laps(iceP_laps),
        driveInfo(iceP_driveInfo),
        image(iceP_image),
        isOver(iceP_isOver)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int ident;
    ::Ice::Long seqIdx;
    ::Ice::Float angle;
    ::Ice::Float curLapTime;
    ::Ice::Float damage;
    ::Ice::Float distFromStart;
    ::Ice::Float distRaced;
    ::Ice::Float fuel;
    ::Ice::Int gear;
    ::Ice::Float lastLapTime;
    ::Race::FloatSeq opponents;
    ::Ice::Int racePos;
    ::Ice::Float rpm;
    ::Ice::Float speedX;
    ::Ice::Float speedY;
    ::Ice::Float speedZ;
    ::Race::FloatSeq track;
    ::Ice::Float trackPos;
    ::Race::FloatSeq wheelSpinVel;
    ::Ice::Float z;
    ::Race::FloatSeq focus;
    ::Ice::Int laps;
    ::Race::DriveInfoPtr driveInfo;
    ::Race::ImagePtr image;
    bool isOver;
};
static ::Ice::ValueFactoryPtr _iceS_Status_init = ::Race::Status::ice_factory();

inline bool operator==(const Status& lhs, const Status& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Status& lhs, const Status& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class BotInitParam : public virtual ::Ice::Object
{
public:

    typedef BotInitParamPrx ProxyType;
    typedef BotInitParamPtr PointerType;

    virtual ~BotInitParam();

    BotInitParam()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};
static ::Ice::ValueFactoryPtr _iceS_BotInitParam_init = ::Race::BotInitParam::ice_factory();

inline bool operator==(const BotInitParam& lhs, const BotInitParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BotInitParam& lhs, const BotInitParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class BotRaceInitParam : public virtual ::Ice::Object
{
public:

    typedef BotRaceInitParamPrx ProxyType;
    typedef BotRaceInitParamPtr PointerType;

    virtual ~BotRaceInitParam();

    BotRaceInitParam() :
        ident(-1),
        screenCapture(false)
    {
    }

    BotRaceInitParam(::Ice::Int iceP_ident, const ::Race::FloatSeq& iceP_angles, bool iceP_screenCapture) :
        ident(iceP_ident),
        angles(iceP_angles),
        screenCapture(iceP_screenCapture)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int ident;
    ::Race::FloatSeq angles;
    bool screenCapture;
};
static ::Ice::ValueFactoryPtr _iceS_BotRaceInitParam_init = ::Race::BotRaceInitParam::ice_factory();

inline bool operator==(const BotRaceInitParam& lhs, const BotRaceInitParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BotRaceInitParam& lhs, const BotRaceInitParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class BotInfo : public virtual ::Ice::Object
{
public:

    typedef BotInfoPrx ProxyType;
    typedef BotInfoPtr PointerType;

    virtual ~BotInfo();

    BotInfo()
    {
    }

    BotInfo(::Ice::Int iceP_idx, const ::std::string& iceP_name) :
        idx(iceP_idx),
        name(iceP_name)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int idx;
    ::std::string name;
};
static ::Ice::ValueFactoryPtr _iceS_BotInfo_init = ::Race::BotInfo::ice_factory();

inline bool operator==(const BotInfo& lhs, const BotInfo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BotInfo& lhs, const BotInfo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class EventParams : public virtual ::Ice::Object
{
public:

    typedef EventParamsPrx ProxyType;
    typedef EventParamsPtr PointerType;

    virtual ~EventParams();

    EventParams()
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};
static ::Ice::ValueFactoryPtr _iceS_EventParams_init = ::Race::EventParams::ice_factory();

inline bool operator==(const EventParams& lhs, const EventParams& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EventParams& lhs, const EventParams& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class StepParam : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef StepParamPrx ProxyType;
    typedef StepParamPtr PointerType;

    virtual ~StepParam();

    StepParam()
    {
    }

    explicit StepParam(const ::Race::DriveInfoList& iceP_driveInfos) :
        driveInfos(iceP_driveInfos)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Race::DriveInfoList driveInfos;
};
static ::Ice::ValueFactoryPtr _iceS_StepParam_init = ::Race::StepParam::ice_factory();

inline bool operator==(const StepParam& lhs, const StepParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const StepParam& lhs, const StepParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class ResetParam : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef ResetParamPrx ProxyType;
    typedef ResetParamPtr PointerType;

    virtual ~ResetParam();

    ResetParam()
    {
    }

    explicit ResetParam(const ::Race::BotRaceInitParamList& iceP_raceInit) :
        raceInit(iceP_raceInit)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Race::BotRaceInitParamList raceInit;
};
static ::Ice::ValueFactoryPtr _iceS_ResetParam_init = ::Race::ResetParam::ice_factory();

inline bool operator==(const ResetParam& lhs, const ResetParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ResetParam& lhs, const ResetParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class StepResult : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef StepResultPrx ProxyType;
    typedef StepResultPtr PointerType;

    virtual ~StepResult();

    StepResult() :
        isOver(false),
        isAllFinished(false)
    {
    }

    StepResult(const ::Race::StatusList& iceP_statusList, bool iceP_isOver, bool iceP_isAllFinished) :
        statusList(iceP_statusList),
        isOver(iceP_isOver),
        isAllFinished(iceP_isAllFinished)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Race::StatusList statusList;
    bool isOver;
    bool isAllFinished;
};
static ::Ice::ValueFactoryPtr _iceS_StepResult_init = ::Race::StepResult::ice_factory();

inline bool operator==(const StepResult& lhs, const StepResult& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const StepResult& lhs, const StepResult& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class ServerInitParam : public virtual ::Ice::Object
{
public:

    typedef ServerInitParamPrx ProxyType;
    typedef ServerInitParamPtr PointerType;

    virtual ~ServerInitParam();

    ServerInitParam() :
        timeMult(1.0F)
    {
    }

    ServerInitParam(const ::std::string& iceP_dataioHost, ::Ice::Int iceP_dataioPort, const ::std::string& iceP_name, ::Ice::Float iceP_timeMult) :
        dataioHost(iceP_dataioHost),
        dataioPort(iceP_dataioPort),
        name(iceP_name),
        timeMult(iceP_timeMult)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::std::string dataioHost;
    ::Ice::Int dataioPort;
    ::std::string name;
    ::Ice::Float timeMult;
};
static ::Ice::ValueFactoryPtr _iceS_ServerInitParam_init = ::Race::ServerInitParam::ice_factory();

inline bool operator==(const ServerInitParam& lhs, const ServerInitParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ServerInitParam& lhs, const ServerInitParam& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class Pool : public virtual ::Ice::Object
{
public:

    typedef PoolPrx ProxyType;
    typedef PoolPtr PointerType;

    virtual ~Pool();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual void onEvent(const ::std::string&, const ::Race::EventParamsPtr&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_onEvent(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Race::DriveInfoList predict(const ::Race::StatusList&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_predict(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const Pool& lhs, const Pool& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Pool& lhs, const Pool& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class Server : public virtual ::Ice::Object
{
public:

    typedef ServerPrx ProxyType;
    typedef ServerPtr PointerType;

    virtual ~Server();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual void init(const ::Ice::Identity&, const ::Race::ServerInitParamPtr&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_init(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Race::BotInfoList getBots(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getBots(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Race::StepResultPtr step(const ::Race::StepParamPtr&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_step(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Race::StepResultPtr reset(const ::Race::ResetParamPtr&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_reset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void shutdown(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const Server& lhs, const Server& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Server& lhs, const Server& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

}

namespace Ice
{

template<typename S>
struct StreamWriter< ::Race::DriveInfo, S>
{
    static void write(S* ostr, const ::Race::DriveInfo& v)
    {
        ostr->write(v.ident);
        ostr->write(v.seqIdx);
        ostr->write(v.steering);
        ostr->write(v.acceleration);
        ostr->write(v.brake);
        ostr->write(v.clutch);
        ostr->write(v.focus);
        ostr->write(v.gear);
    }
};

template<typename S>
struct StreamReader< ::Race::DriveInfo, S>
{
    static void read(S* istr, ::Race::DriveInfo& v)
    {
        istr->read(v.ident);
        istr->read(v.seqIdx);
        istr->read(v.steering);
        istr->read(v.acceleration);
        istr->read(v.brake);
        istr->read(v.clutch);
        istr->read(v.focus);
        istr->read(v.gear);
    }
};

template<typename S>
struct StreamWriter< ::Race::Image, S>
{
    static void write(S* ostr, const ::Race::Image& v)
    {
        ostr->write(v.width);
        ostr->write(v.height);
        ostr->write(v.data);
    }
};

template<typename S>
struct StreamReader< ::Race::Image, S>
{
    static void read(S* istr, ::Race::Image& v)
    {
        istr->read(v.width);
        istr->read(v.height);
        istr->read(v.data);
    }
};

template<typename S>
struct StreamWriter< ::Race::Status, S>
{
    static void write(S* ostr, const ::Race::Status& v)
    {
        ostr->write(v.ident);
        ostr->write(v.seqIdx);
        ostr->write(v.angle);
        ostr->write(v.curLapTime);
        ostr->write(v.damage);
        ostr->write(v.distFromStart);
        ostr->write(v.distRaced);
        ostr->write(v.fuel);
        ostr->write(v.gear);
        ostr->write(v.lastLapTime);
        ostr->write(v.opponents);
        ostr->write(v.racePos);
        ostr->write(v.rpm);
        ostr->write(v.speedX);
        ostr->write(v.speedY);
        ostr->write(v.speedZ);
        ostr->write(v.track);
        ostr->write(v.trackPos);
        ostr->write(v.wheelSpinVel);
        ostr->write(v.z);
        ostr->write(v.focus);
        ostr->write(v.laps);
        ostr->write(v.driveInfo);
        ostr->write(v.image);
        ostr->write(v.isOver);
    }
};

template<typename S>
struct StreamReader< ::Race::Status, S>
{
    static void read(S* istr, ::Race::Status& v)
    {
        istr->read(v.ident);
        istr->read(v.seqIdx);
        istr->read(v.angle);
        istr->read(v.curLapTime);
        istr->read(v.damage);
        istr->read(v.distFromStart);
        istr->read(v.distRaced);
        istr->read(v.fuel);
        istr->read(v.gear);
        istr->read(v.lastLapTime);
        istr->read(v.opponents);
        istr->read(v.racePos);
        istr->read(v.rpm);
        istr->read(v.speedX);
        istr->read(v.speedY);
        istr->read(v.speedZ);
        istr->read(v.track);
        istr->read(v.trackPos);
        istr->read(v.wheelSpinVel);
        istr->read(v.z);
        istr->read(v.focus);
        istr->read(v.laps);
        istr->read(v.driveInfo);
        istr->read(v.image);
        istr->read(v.isOver);
    }
};

template<typename S>
struct StreamWriter< ::Race::BotRaceInitParam, S>
{
    static void write(S* ostr, const ::Race::BotRaceInitParam& v)
    {
        ostr->write(v.ident);
        ostr->write(v.angles);
        ostr->write(v.screenCapture);
    }
};

template<typename S>
struct StreamReader< ::Race::BotRaceInitParam, S>
{
    static void read(S* istr, ::Race::BotRaceInitParam& v)
    {
        istr->read(v.ident);
        istr->read(v.angles);
        istr->read(v.screenCapture);
    }
};

template<typename S>
struct StreamWriter< ::Race::BotInfo, S>
{
    static void write(S* ostr, const ::Race::BotInfo& v)
    {
        ostr->write(v.idx);
        ostr->write(v.name);
    }
};

template<typename S>
struct StreamReader< ::Race::BotInfo, S>
{
    static void read(S* istr, ::Race::BotInfo& v)
    {
        istr->read(v.idx);
        istr->read(v.name);
    }
};

template<typename S>
struct StreamWriter< ::Race::StepParam, S>
{
    static void write(S* ostr, const ::Race::StepParam& v)
    {
        ostr->write(v.driveInfos);
    }
};

template<typename S>
struct StreamReader< ::Race::StepParam, S>
{
    static void read(S* istr, ::Race::StepParam& v)
    {
        istr->read(v.driveInfos);
    }
};

template<typename S>
struct StreamWriter< ::Race::ResetParam, S>
{
    static void write(S* ostr, const ::Race::ResetParam& v)
    {
        ostr->write(v.raceInit);
    }
};

template<typename S>
struct StreamReader< ::Race::ResetParam, S>
{
    static void read(S* istr, ::Race::ResetParam& v)
    {
        istr->read(v.raceInit);
    }
};

template<typename S>
struct StreamWriter< ::Race::StepResult, S>
{
    static void write(S* ostr, const ::Race::StepResult& v)
    {
        ostr->write(v.statusList);
        ostr->write(v.isOver);
        ostr->write(v.isAllFinished);
    }
};

template<typename S>
struct StreamReader< ::Race::StepResult, S>
{
    static void read(S* istr, ::Race::StepResult& v)
    {
        istr->read(v.statusList);
        istr->read(v.isOver);
        istr->read(v.isAllFinished);
    }
};

template<typename S>
struct StreamWriter< ::Race::ServerInitParam, S>
{
    static void write(S* ostr, const ::Race::ServerInitParam& v)
    {
        ostr->write(v.dataioHost);
        ostr->write(v.dataioPort);
        ostr->write(v.name);
        ostr->write(v.timeMult);
    }
};

template<typename S>
struct StreamReader< ::Race::ServerInitParam, S>
{
    static void read(S* istr, ::Race::ServerInitParam& v)
    {
        istr->read(v.dataioHost);
        istr->read(v.dataioPort);
        istr->read(v.name);
        istr->read(v.timeMult);
    }
};

}

namespace Race
{

template<class T>
class CallbackNC_Pool_onEvent : public Callback_Pool_onEvent_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Pool_onEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Pool_onEventPtr
newCallback_Pool_onEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_onEvent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Pool_onEventPtr
newCallback_Pool_onEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_onEvent<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Pool_onEventPtr
newCallback_Pool_onEvent(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_onEvent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Pool_onEventPtr
newCallback_Pool_onEvent(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_onEvent<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Pool_onEvent : public Callback_Pool_onEvent_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Pool_onEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Pool_onEventPtr
newCallback_Pool_onEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_onEvent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Pool_onEventPtr
newCallback_Pool_onEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_onEvent<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Pool_onEventPtr
newCallback_Pool_onEvent(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_onEvent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Pool_onEventPtr
newCallback_Pool_onEvent(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_onEvent<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Pool_predict : public Callback_Pool_predict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Race::DriveInfoList&);

    CallbackNC_Pool_predict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Race::PoolPrx proxy = ::Race::PoolPrx::uncheckedCast(result->getProxy());
        ::Race::DriveInfoList ret;
        try
        {
            ret = proxy->end_predict(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_Pool_predictPtr
newCallback_Pool_predict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Race::DriveInfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_predict<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Pool_predictPtr
newCallback_Pool_predict(T* instance, void (T::*cb)(const ::Race::DriveInfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Pool_predict<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Pool_predict : public Callback_Pool_predict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Race::DriveInfoList&, const CT&);

    Callback_Pool_predict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Race::PoolPrx proxy = ::Race::PoolPrx::uncheckedCast(result->getProxy());
        ::Race::DriveInfoList ret;
        try
        {
            ret = proxy->end_predict(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_Pool_predictPtr
newCallback_Pool_predict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Race::DriveInfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_predict<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Pool_predictPtr
newCallback_Pool_predict(T* instance, void (T::*cb)(const ::Race::DriveInfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Pool_predict<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_init : public Callback_Server_init_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Server_initPtr
newCallback_Server_init(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_init<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_initPtr
newCallback_Server_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_init<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_initPtr
newCallback_Server_init(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_init<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_initPtr
newCallback_Server_init(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_init<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_init : public Callback_Server_init_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Server_initPtr
newCallback_Server_init(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_init<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_initPtr
newCallback_Server_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_init<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_initPtr
newCallback_Server_init(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_init<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_initPtr
newCallback_Server_init(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_init<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Server_getBots : public Callback_Server_getBots_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Race::BotInfoList&);

    CallbackNC_Server_getBots(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Race::ServerPrx proxy = ::Race::ServerPrx::uncheckedCast(result->getProxy());
        ::Race::BotInfoList ret;
        try
        {
            ret = proxy->end_getBots(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_Server_getBotsPtr
newCallback_Server_getBots(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Race::BotInfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getBots<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_getBotsPtr
newCallback_Server_getBots(T* instance, void (T::*cb)(const ::Race::BotInfoList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_getBots<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_getBots : public Callback_Server_getBots_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Race::BotInfoList&, const CT&);

    Callback_Server_getBots(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Race::ServerPrx proxy = ::Race::ServerPrx::uncheckedCast(result->getProxy());
        ::Race::BotInfoList ret;
        try
        {
            ret = proxy->end_getBots(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_Server_getBotsPtr
newCallback_Server_getBots(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Race::BotInfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getBots<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_getBotsPtr
newCallback_Server_getBots(T* instance, void (T::*cb)(const ::Race::BotInfoList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_getBots<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_step : public Callback_Server_step_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Race::StepResultPtr&);

    CallbackNC_Server_step(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Race::ServerPrx proxy = ::Race::ServerPrx::uncheckedCast(result->getProxy());
        ::Race::StepResultPtr ret;
        try
        {
            ret = proxy->end_step(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_Server_stepPtr
newCallback_Server_step(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Race::StepResultPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_step<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_stepPtr
newCallback_Server_step(T* instance, void (T::*cb)(const ::Race::StepResultPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_step<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_step : public Callback_Server_step_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Race::StepResultPtr&, const CT&);

    Callback_Server_step(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Race::ServerPrx proxy = ::Race::ServerPrx::uncheckedCast(result->getProxy());
        ::Race::StepResultPtr ret;
        try
        {
            ret = proxy->end_step(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_Server_stepPtr
newCallback_Server_step(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Race::StepResultPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_step<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_stepPtr
newCallback_Server_step(T* instance, void (T::*cb)(const ::Race::StepResultPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_step<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_reset : public Callback_Server_reset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Race::StepResultPtr&);

    CallbackNC_Server_reset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Race::ServerPrx proxy = ::Race::ServerPrx::uncheckedCast(result->getProxy());
        ::Race::StepResultPtr ret;
        try
        {
            ret = proxy->end_reset(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_Server_resetPtr
newCallback_Server_reset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Race::StepResultPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_reset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_resetPtr
newCallback_Server_reset(T* instance, void (T::*cb)(const ::Race::StepResultPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_reset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_reset : public Callback_Server_reset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Race::StepResultPtr&, const CT&);

    Callback_Server_reset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Race::ServerPrx proxy = ::Race::ServerPrx::uncheckedCast(result->getProxy());
        ::Race::StepResultPtr ret;
        try
        {
            ret = proxy->end_reset(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_Server_resetPtr
newCallback_Server_reset(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Race::StepResultPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_reset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_resetPtr
newCallback_Server_reset(T* instance, void (T::*cb)(const ::Race::StepResultPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_reset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Server_shutdown : public Callback_Server_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Server_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Server_shutdownPtr
newCallback_Server_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_shutdownPtr
newCallback_Server_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Server_shutdownPtr
newCallback_Server_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_shutdown<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Server_shutdownPtr
newCallback_Server_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Server_shutdown<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Server_shutdown : public Callback_Server_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Server_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Server_shutdownPtr
newCallback_Server_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_shutdownPtr
newCallback_Server_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_shutdown<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Server_shutdownPtr
newCallback_Server_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_shutdown<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Server_shutdownPtr
newCallback_Server_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Server_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
